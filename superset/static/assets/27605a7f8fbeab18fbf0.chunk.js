(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{4645:function(t,e,n){"use strict";n.d(e,"f",(function(){return o})),n.d(e,"a",(function(){return i})),n.d(e,"b",(function(){return p})),n.d(e,"d",(function(){return g})),n.d(e,"e",(function(){return v})),n.d(e,"c",(function(){return m}));n(4637);const i={CLOCKWISE:1,COUNTER_CLOCKWISE:-1};function o(t,e,n={}){return function(t,e={}){return Math.sign(s(t,e))}(t,n)!==e&&(function(t,e){const{start:n=0,end:i=t.length,size:o=2}=e,s=(i-n)/o,r=Math.floor(s/2);for(let e=0;e<r;++e){const i=n+e*o,r=n+(s-1-e)*o;for(let e=0;e<o;++e){const n=t[i+e];t[i+e]=t[r+e],t[r+e]=n}}}(t,n),!0)}function s(t,e={}){const{start:n=0,end:i=t.length}=e,o=e.size||2;let s=0;for(let e=n,r=i-o;e<i;e+=o)s+=(t[e]-t[r])*(t[e+1]+t[r+1]),r=e;return s/2}function r(t,e){const n=e.length,i=t.length;if(i>0){let o=!0;for(let s=0;s<n;s++)if(t[i-n+s]!==e[s]){o=!1;break}if(o)return!1}for(let o=0;o<n;o++)t[i+o]=e[o];return!0}function a(t,e){const n=e.length;for(let i=0;i<n;i++)t[i]=e[i]}function l(t,e,n,i,o=[]){const s=i+e*n;for(let e=0;e<n;e++)o[e]=t[s+e];return o}function c(t,e,n,i,o=[]){let s,r;if(8&n)s=(i[3]-t[1])/(e[1]-t[1]),r=3;else if(4&n)s=(i[1]-t[1])/(e[1]-t[1]),r=1;else if(2&n)s=(i[2]-t[0])/(e[0]-t[0]),r=2;else{if(!(1&n))return null;s=(i[0]-t[0])/(e[0]-t[0]),r=0}for(let n=0;n<t.length;n++)o[n]=(1&r)===n?i[r]:s*(e[n]-t[n])+t[n];return o}function u(t,e){let n=0;return t[0]<e[0]?n|=1:t[0]>e[2]&&(n|=2),t[1]<e[1]?n|=4:t[1]>e[3]&&(n|=8),n}function g(t,e={}){const{size:n=2,broken:i=!1,gridResolution:o=10,gridOffset:s=[0,0],startIndex:g=0,endIndex:d=t.length}=e,p=(d-g)/n;let h=[];const y=[h],v=l(t,0,n,g);let m,_;const P=f(v,o,s,[]),b=[];r(h,v);for(let e=1;e<p;e++){for(m=l(t,e,n,g,m),_=u(m,P);_;){c(v,m,_,P,b);const t=u(b,P);t&&(c(v,b,t,P,b),_=t),r(h,b),a(v,b),x(P,o,_),i&&h.length>n&&(h=[],y.push(h),r(h,v)),_=u(m,P)}r(h,m),a(v,m)}return i?y:y[0]}function d(t,e){for(let n=0;n<e.length;n++)t.push(e[n]);return t}function p(t,e,n={}){if(!t.length)return[];const{size:i=2,gridResolution:o=10,gridOffset:s=[0,0],edgeTypes:r=!1}=n,a=[],l=[{pos:t,types:r&&new Array(t.length/i).fill(1),holes:e||[]}],c=[[],[]];let g=[];for(;l.length;){const{pos:t,types:e,holes:n}=l.shift();y(t,i,n[0]||t.length,c),g=f(c[0],o,s,g);const p=u(c[1],g);if(p){let o=h(t,e,i,0,n[0]||t.length,g,p);const s={pos:o[0].pos,types:o[0].types,holes:[]},a={pos:o[1].pos,types:o[1].types,holes:[]};l.push(s,a);for(let l=0;l<n.length;l++)o=h(t,e,i,n[l],n[l+1]||t.length,g,p),o[0]&&(s.holes.push(s.pos.length),s.pos=d(s.pos,o[0].pos),r&&(s.types=d(s.types,o[0].types))),o[1]&&(a.holes.push(a.pos.length),a.pos=d(a.pos,o[1].pos),r&&(a.types=d(a.types,o[1].types)))}else{const i={positions:t};r&&(i.edgeTypes=e),n.length&&(i.holeIndices=n),a.push(i)}}return a}function h(t,e,n,i,o,s,u){const g=(o-i)/n,d=[],p=[],h=[],f=[],x=[];let y,v,m;const _=l(t,g-1,n,i);let P=Math.sign(8&u?_[1]-s[3]:_[0]-s[2]),b=e&&e[g-1],C=0,S=0;for(let o=0;o<g;o++)y=l(t,o,n,i,y),v=Math.sign(8&u?y[1]-s[3]:y[0]-s[2]),m=e&&e[i/n+o],v&&P&&P!==v&&(c(_,y,u,s,x),r(d,x)&&h.push(b),r(p,x)&&f.push(b)),v<=0?(r(d,y)&&h.push(m),C-=v):h.length&&(h[h.length-1]=0),v>=0?(r(p,y)&&f.push(m),S+=v):f.length&&(f[f.length-1]=0),a(_,y),P=v,b=m;return[C?{pos:d,types:e&&h}:null,S?{pos:p,types:e&&f}:null]}function f(t,e,n,i){const o=Math.floor((t[0]-n[0])/e)*e+n[0],s=Math.floor((t[1]-n[1])/e)*e+n[1];return i[0]=o,i[1]=s,i[2]=o+e,i[3]=s+e,i}function x(t,e,n){8&n?(t[1]+=e,t[3]+=e):4&n?(t[1]-=e,t[3]-=e):2&n?(t[0]+=e,t[2]+=e):1&n&&(t[0]-=e,t[2]-=e)}function y(t,e,n,i){let o=1/0,s=-1/0,r=1/0,a=-1/0;for(let i=0;i<n;i+=e){const e=t[i],n=t[i+1];o=e<o?e:o,s=e>s?e:s,r=n<r?n:r,a=n>a?n:a}return i[0][0]=o,i[0][1]=r,i[1][0]=s,i[1][1]=a,i}function v(t,e={}){const{size:n=2,startIndex:i=0,endIndex:o=t.length,normalize:s=!0}=e,r=t.slice(i,o);b(r,n,0,o-i);const a=g(r,{size:n,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(s)for(const t of a)C(t,n);return a}function m(t,e,n={}){const{size:i=2,normalize:o=!0,edgeTypes:s=!1}=n;e=e||[];const r=[],a=[];let l=0,c=0;for(let o=0;o<=e.length;o++){const s=e[o]||t.length,u=c,g=_(t,i,l,s);for(let e=g;e<s;e++)r[c++]=t[e];for(let e=l;e<g;e++)r[c++]=t[e];b(r,i,u,c),P(r,i,u,c,n.maxLatitude),l=s,a[o]=c}a.pop();const u=p(r,a,{size:i,gridResolution:360,gridOffset:[-180,-180],edgeTypes:s});if(o)for(const t of u)C(t.positions,i);return u}function _(t,e,n,i){let o=-1,s=-1;for(let r=n+1;r<i;r+=e){const e=Math.abs(t[r]);e>o&&(o=e,s=r-1)}return s}function P(t,e,n,i,o=85.051129){const s=t[n],a=t[i-e];if(Math.abs(s-a)>180){const i=l(t,0,e,n);i[0]+=360*Math.round((a-s)/360),r(t,i),i[1]=Math.sign(i[1])*o,r(t,i),i[0]=s,r(t,i)}}function b(t,e,n,i){let o,s=t[0];for(let r=n;r<i;r+=e){o=t[r];const e=o-s;(e>180||e<-180)&&(o-=360*Math.round(e/360)),t[r]=s=o}}function C(t,e){let n;const i=t.length/e;for(let o=0;o<i&&(n=t[o*e],(n+180)%360==0);o++);const o=360*-Math.round(n/360);if(0!==o)for(let n=0;n<i;n++)t[n*e]+=o}},4693:function(t,e,n){"use strict";n.d(e,"b",(function(){return g})),n.d(e,"a",(function(){return d}));var i=n(4724),o=n.n(i),s=n(4645);const r=s.a.CLOCKWISE,a=s.a.COUNTER_CLOCKWISE,l={isClosed:!0};function c(t,e,n,i,o){let r=e;const a=n.length;for(let e=0;e<a;e++)for(let o=0;o<i;o++)t[r++]=n[e][o]||0;if(!function(t){const e=t[0],n=t[t.length-1];return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]}(n))for(let e=0;e<i;e++)t[r++]=n[0][e]||0;return l.start=e,l.end=r,l.size=i,Object(s.f)(t,o,l),r}function u(t,e,n,i,o=0,r,a){const c=(r=r||n.length)-o;if(c<=0)return e;let u=e;for(let e=0;e<c;e++)t[u++]=n[o+e];if(!function(t,e,n,i){for(let o=0;o<e;o++)if(t[n+o]!==t[i-e+o])return!1;return!0}(n,i,o,r))for(let e=0;e<i;e++)t[u++]=n[o+e];return l.start=e,l.end=u,l.size=i,Object(s.f)(t,a,l),u}function g(t,e){!function(t){if(t=t&&t.positions||t,!Array.isArray(t)&&!ArrayBuffer.isView(t))throw new Error("invalid polygon")}(t);const n=[],i=[];if(t.positions){const{positions:o,holeIndices:s}=t;if(s){let t=0;for(let l=0;l<=s.length;l++)t=u(n,t,o,e,s[l-1],s[l],0===l?r:a),i.push(t);return i.pop(),{positions:n,holeIndices:i}}t=o}if(Number.isFinite(t[0]))return u(n,0,t,e,0,n.length,r),n;if(!function(t){return t.length>=1&&t[0].length>=2&&Number.isFinite(t[0][0])}(t)){let o=0;for(const[s,l]of t.entries())o=c(n,o,l,e,0===s?r:a),i.push(o);return i.pop(),{positions:n,holeIndices:i}}return c(n,0,t,e,r),n}function d(t,e,n){let i=null;t.holeIndices&&(i=t.holeIndices.map(t=>t/e));let s=t.positions||t;if(n){const t=s.length;s=s.slice();const i=[];for(let o=0;o<t;o+=e){i[0]=s[o],i[1]=s[o+1];const t=n(i);s[o]=t[0],s[o+1]=t[1]}}return o()(s,i,e)}},4698:function(t,e,n){"use strict";n.d(e,"a",(function(){return f}));var i=n(4717),o=n(4802),s=n(4837),r=n(4653),a=n(4992),l=n(4803),c=n(4757),u=n(4645);class g extends c.a{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):()=>null}normalizeGeometry(t){return this.normalize?function(t,e,n,i){let o=t;if(Array.isArray(t[0])){const n=t.length*e;o=new Array(n);for(let n=0;n<t.length;n++)for(let i=0;i<e;i++)o[n*e+i]=t[n][i]||0}return n?Object(u.d)(o,{size:e,gridResolution:n}):i?Object(u.e)(o,{size:e}):o}(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}get(t){return this.attributes[t]}getGeometrySize(t){if(Array.isArray(t[0])){let e=0;for(const n of t)e+=this.getGeometrySize(n);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&Array.isArray(t[0]))for(const n of t){const t=this.getGeometrySize(n);e.geometrySize=t,this.updateGeometryAttributes(n,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const{segmentTypes:n}=this.attributes,i=this.isClosed(t),{vertexStart:o,geometrySize:s}=e;n.fill(0,o,o+s),i?(n[o]=4,n[o+s-2]=4):(n[o]+=1,n[o+s-2]+=2),n[o+s-1]=4}_updatePositions(t,e){const{positions:n}=this.attributes;if(!n)return;const{vertexStart:i,geometrySize:o}=e,s=new Array(3);for(let e=i,r=0;r<o;e++,r++)this.getPointOnPath(t,r,s),n[3*e]=s[0],n[3*e+1]=s[1],n[3*e+2]=s[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,n=[]){const{positionSize:i}=this;e*i>=t.length&&(e+=1-t.length/i);const o=e*i;return n[0]=t[o],n[1]=t[o+1],n[2]=3===i&&t[o+2]||0,n}isClosed(t){if(!this.normalize)return this.opts.loop;const{positionSize:e}=this,n=t.length-e;return t[0]===t[n]&&t[1]===t[n+1]&&(2===e||t[2]===t[n+2])}}const d=[0,0,0,255],p={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:d},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},h={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class f extends i.a{getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.worldPosition = instanceStartPositions;\n  geometry.worldPositionAlt = instanceEndPositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.a,s.a]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:h,accessor:"getPath",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:h,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:h,defaultValue:d},instancePickingColors:{size:3,type:5121,accessor:(t,{index:e,target:n})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,n)}}),this.setState({pathTesselator:new g({fp64:this.use64bitPositions()})}),this.props.getDashArray&&!this.props.extensions.length&&r.a.removed("getDashArray","PathStyleExtension")()}updateState({oldProps:t,props:e,changeFlags:n}){super.updateState({props:e,oldProps:t,changeFlags:n});const i=this.getAttributeManager();if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,o=e.data.attributes||{};t.updateGeometry({data:e.data,geometryBuffer:o.getPath,buffers:o,normalize:!e._pathType,loop:"loop"===e._pathType,getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:n.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),n.dataChanged||i.invalidateAll()}if(n.extensionsChanged){var o;const{gl:t}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(t),i.invalidateAll()}}getPickingInfo(t){const e=super.getPickingInfo(t),{index:n}=e,{data:i}=this.props;return i[0]&&i[0].__source&&(e.object=i.find(t=>t.__source.index===n)),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let n=0;n<e.length;n++)e[n].__source.index===t&&this._disablePickingIndex(n);else this._disablePickingIndex(t)}draw({uniforms:t}){const{viewport:e}=this.context,{jointRounded:n,capRounded:i,billboard:o,miterLimit:s,widthUnits:r,widthScale:a,widthMinPixels:l,widthMaxPixels:c}=this.props,u="pixels"===r?e.metersPerPixel:1;this.state.model.setUniforms(t).setUniforms({jointType:Number(n),capType:Number(i),billboard:o,widthScale:a*u,miterLimit:s,widthMinPixels:l,widthMaxPixels:c}).draw()}_getModel(t){return new a.a(t,{...this.getShaders(),id:this.props.id,geometry:new l.a({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}f.layerName="PathLayer",f.defaultProps=p},4712:function(t,e,n){"use strict";function i({data:t,getIndex:e,dataRange:n,replace:i}){const{startRow:o=0,endRow:s=1/0}=n,r=t.length;let a=r,l=r;for(let n=0;n<r;n++){const i=e(t[n]);if(a>n&&i>=o&&(a=n),i>=s){l=n;break}}let c=a;const u=l-a!==i.length,g=u&&t.slice(l);for(let e=0;e<i.length;e++)t[c++]=i[e];if(u){for(let e=0;e<g.length;e++)t[c++]=g[e];t.length=c}return{startRow:a,endRow:a+i.length}}n.d(e,"a",(function(){return i}))},4718:function(t,e,n){"use strict";n.d(e,"a",(function(){return b}));var i=n(4717),o=n(4802),s=n(4739),r=n(4837),a=n(4690),l=n(5018),c=n(4867),u=n(4992),g=n(4803),d=n(4693),p=n(4757),h=n(4645);class f extends p.a{constructor(t){const{fp64:e,IndexType:n=Uint32Array}=t;super({...t,attributes:{positions:{size:3,type:e?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:n,size:1}}})}get(t){const{attributes:e}=this;return"indices"===t?e.indices&&e.indices.subarray(0,this.vertexCount):e[t]}updateGeometry(t){super.updateGeometry(t);const e=this.buffers.indices;e&&(this.vertexCount=(e.value||e).length)}normalizeGeometry(t){if(this.normalize){if(t=d.b(t,this.positionSize),this.opts.resolution)return Object(h.b)(t.positions||t,t.holeIndices,{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0});if(this.opts.wrapLongitude)return Object(h.c)(t.positions||t,t.holeIndices,{size:this.positionSize,maxLatitude:86,edgeTypes:!0})}return t}getGeometrySize(t){if(Array.isArray(t)&&!Number.isFinite(t[0])){let e=0;for(const n of t)e+=this.getGeometrySize(n);return e}return(t.positions||t).length/this.positionSize}getGeometryFromBuffer(t){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(t):()=>null}updateGeometryAttributes(t,e){if(Array.isArray(t)&&!Number.isFinite(t[0]))for(const n of t){const t=this.getGeometrySize(n);e.geometrySize=t,this.updateGeometryAttributes(n,e),e.vertexStart+=t,e.indexStart=this.indexStarts[e.geometryIndex+1]}else this._updateIndices(t,e),this._updatePositions(t,e),this._updateVertexValid(t,e)}_updateIndices(t,{geometryIndex:e,vertexStart:n,indexStart:i}){const{attributes:o,indexStarts:s,typedArrayManager:r}=this;let a=o.indices;if(!a)return;let l=i;const c=d.a(t,this.positionSize,this.opts.preproject);a=r.allocate(a,i+c.length,{copy:!0});for(let t=0;t<c.length;t++)a[l++]=c[t]+n;s[e+1]=i+c.length,o.indices=a}_updatePositions(t,{vertexStart:e,geometrySize:n}){const{attributes:{positions:i},positionSize:o}=this;if(!i)return;const s=t.positions||t;for(let t=e,r=0;r<n;t++,r++){const e=s[r*o],n=s[r*o+1],a=o>2?s[r*o+2]:0;i[3*t]=e,i[3*t+1]=n,i[3*t+2]=a}}_updateVertexValid(t,{vertexStart:e,geometrySize:n}){const{attributes:{vertexValid:i},positionSize:o}=this,s=t&&t.holeIndices;if(t&&t.edgeTypes?i.set(t.edgeTypes,e):i.fill(1,e,e+n),s)for(let t=0;t<s.length;t++)i[e+s[t]/o-1]=0;i[e+n-1]=0}}var x="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n\n#ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n    geometry.normal = normal;\n  }\n\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",y="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(x,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),v="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(x,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n");const m=[0,0,0,255],_={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:t=>t.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:m},getLineColor:{type:"accessor",value:m},material:!0},P={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class b extends i.a{getShaders(t){return super.getShaders({vs:"top"===t?y:v,fs:"#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[o.a,s.a,r.a]})}get wrapLongitude(){return!1}initializeState(){const{gl:t,viewport:e}=this.context;let{coordinateSystem:n}=this.props;e.isGeospatial&&n===a.a.DEFAULT&&(n=a.a.LNGLAT),this.setState({numInstances:0,polygonTesselator:new f({preproject:n===a.a.LNGLAT&&e.projectFlat,fp64:this.use64bitPositions(),IndexType:!t||Object(l.c)(t,c.a.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const i=this.getAttributeManager();i.remove(["instancePickingColors"]),i.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:!0},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:P,accessor:"getPolygon",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:!0},elevations:{size:1,transition:P,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{alias:"colors",size:this.props.colorFormat.length,type:5121,normalized:!0,transition:P,accessor:"getFillColor",defaultValue:m,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{alias:"colors",size:this.props.colorFormat.length,type:5121,normalized:!0,transition:P,accessor:"getLineColor",defaultValue:m,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(t,{index:e,target:n})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,n),shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:n}=e,{data:i}=this.props;return i[0]&&i[0].__source&&(e.object=i.find(t=>t.__source.index===n)),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let n=0;n<e.length;n++)e[n].__source.index===t&&this._disablePickingIndex(n);else this._disablePickingIndex(t)}draw({uniforms:t}){const{extruded:e,filled:n,wireframe:i,elevationScale:o}=this.props,{topModel:s,sideModel:r,polygonTesselator:a}=this.state,l={...t,extruded:Boolean(e),elevationScale:o};r&&(r.setInstanceCount(a.instanceCount-1),r.setUniforms(l),i&&(r.setDrawMode(3),r.setUniforms({isWireframe:!0}).draw()),n&&(r.setDrawMode(6),r.setUniforms({isWireframe:!1}).draw())),s&&(s.setVertexCount(a.vertexCount),s.setUniforms(l).draw())}updateState(t){super.updateState(t),this.updateGeometry(t);const{props:e,oldProps:n,changeFlags:i}=t,o=this.getAttributeManager();var s;(i.extensionsChanged||e.filled!==n.filled||e.extruded!==n.extruded)&&(null===(s=this.state.models)||void 0===s||s.forEach(t=>t.delete()),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}updateGeometry({props:t,oldProps:e,changeFlags:n}){if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon)){const{polygonTesselator:e}=this.state,i=t.data.attributes||{};e.updateGeometry({data:t.data,normalize:t._normalize,geometryBuffer:i.getPolygon,buffers:i,getGeometry:t.getPolygon,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:n.dataChanged}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),n.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(t){const{id:e,filled:n,extruded:i}=this.props;let o,s;if(n){const n=this.getShaders("top");n.defines.NON_INSTANCED_MODEL=1,o=new u.a(t,{...n,id:"".concat(e,"-top"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return i&&(s=new u.a(t,{...this.getShaders("side"),id:"".concat(e,"-side"),geometry:new g.a({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),s.userData.excludeAttributes={indices:!0}),{models:[s,o].filter(Boolean),topModel:o,sideModel:s}}calculateIndices(t){const{polygonTesselator:e}=this.state;t.startIndices=e.indexStarts,t.value=e.get("indices")}calculatePositions(t){const{polygonTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}}b.layerName="SolidPolygonLayer",b.defaultProps=_},4723:function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var i=n(4717),o=n(4667),s=n(4678);class r extends i.a{get isComposite(){return!0}get isLoaded(){return super.isLoaded&&this.getSubLayers().every(t=>t.isLoaded)}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(){}setState(t){super.setState(t),this.setNeedsUpdate()}getPickingInfo({info:t}){const{object:e}=t;return e&&e.__source&&e.__source.parent&&e.__source.parent.id===this.id?(t.object=e.__source.object,t.index=e.__source.index,t):t}renderLayers(){return null}filterSubLayer(t){return!0}shouldRenderSubLayer(t,e){const{_subLayerProps:n}=this.props;return e&&e.length||n&&n[t]}getSubLayerClass(t,e){const{_subLayerProps:n}=this.props;return n&&n[t]&&n[t].type||e}getSubLayerRow(t,e,n){return t.__source={parent:this,object:e,index:n},t}getSubLayerAccessor(t){if("function"==typeof t){const e={data:this.props.data,target:[]};return(n,i)=>n&&n.__source?(e.index=n.__source.index,t(n.__source.object,e)):t(n,i)}return t}getSubLayerProps(t={}){const{opacity:e,pickable:n,visible:i,parameters:o,getPolygonOffset:s,highlightedObjectIndex:r,autoHighlight:a,highlightColor:l,coordinateSystem:c,coordinateOrigin:u,wrapLongitude:g,positionFormat:d,modelMatrix:p,extensions:h,fetch:f,_subLayerProps:x}=this.props,y={opacity:e,pickable:n,visible:i,parameters:o,getPolygonOffset:s,highlightedObjectIndex:r,autoHighlight:a,highlightColor:l,coordinateSystem:c,coordinateOrigin:u,wrapLongitude:g,positionFormat:d,modelMatrix:p,extensions:h,fetch:f},v=x&&x[t.id],m=v&&v.updateTriggers,_=t.id||"sublayer";if(v){const e=this.constructor._propTypes,n=t.type?t.type._propTypes:{};for(const t in v){const i=n[t]||e[t];i&&"accessor"===i.type&&(v[t]=this.getSubLayerAccessor(v[t]))}}Object.assign(y,t,v),y.id="".concat(this.props.id,"-").concat(_),y.updateTriggers={all:this.props.updateTriggers.all,...t.updateTriggers,...m};for(const t of h){const e=t.getSubLayerProps.call(this,t);e&&Object.assign(y,e,{updateTriggers:Object.assign(y.updateTriggers,e.updateTriggers)})}return y}_updateAutoHighlight(t){for(const e of this.getSubLayers())e.updateAutoHighlight(t)}_getAttributeManager(){return null}_renderLayers(){let{subLayers:t}=this.internalState;const e=!t||this.needsUpdate();e&&(t=this.renderLayers(),t=Object(s.b)(t,Boolean),this.internalState.subLayers=t),Object(o.a)("compositeLayer.renderLayers",this,e,t);for(const e of t)e.parent=this}}r.layerName="CompositeLayer"},4724:function(t,e,n){"use strict";function i(t,e,n){n=n||2;var i,a,l,c,u,p,h,x=e&&e.length,y=x?e[0]*n:t.length,v=o(t,0,y,n,!0),m=[];if(!v||v.next===v.prev)return m;if(x&&(v=function(t,e,n,i){var r,a,l,c,u,p=[];for(r=0,a=e.length;r<a;r++)l=e[r]*i,c=r<a-1?e[r+1]*i:t.length,(u=o(t,l,c,i,!1))===u.next&&(u.steiner=!0),p.push(f(u));for(p.sort(g),r=0;r<p.length;r++)d(p[r],n),n=s(n,n.next);return n}(t,e,v,n)),t.length>80*n){i=l=t[0],a=c=t[1];for(var _=n;_<y;_+=n)(u=t[_])<i&&(i=u),(p=t[_+1])<a&&(a=p),u>l&&(l=u),p>c&&(c=p);h=0!==(h=Math.max(l-i,c-a))?1/h:0}return r(v,m,n,i,a,h),m}function o(t,e,n,i,o){var s,r;if(o===A(t,e,n,i)>0)for(s=e;s<n;s+=i)r=L(s,t[s],t[s+1],r);else for(s=n-i;s>=e;s-=i)r=L(s,t[s],t[s+1],r);return r&&m(r,r.next)&&(w(r),r=r.next),r}function s(t,e){if(!t)return t;e||(e=t);var n,i=t;do{if(n=!1,i.steiner||!m(i,i.next)&&0!==v(i.prev,i,i.next))i=i.next;else{if(w(i),(i=e=i.prev)===i.next)break;n=!0}}while(n||i!==e);return e}function r(t,e,n,i,o,g,d){if(t){!d&&g&&function(t,e,n,i){var o=t;do{null===o.z&&(o.z=h(o.x,o.y,e,n,i)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==t);o.prevZ.nextZ=null,o.prevZ=null,function(t){var e,n,i,o,s,r,a,l,c=1;do{for(n=t,t=null,s=null,r=0;n;){for(r++,i=n,a=0,e=0;e<c&&(a++,i=i.nextZ);e++);for(l=c;a>0||l>0&&i;)0!==a&&(0===l||!i||n.z<=i.z)?(o=n,n=n.nextZ,a--):(o=i,i=i.nextZ,l--),s?s.nextZ=o:t=o,o.prevZ=s,s=o;n=i}s.nextZ=null,c*=2}while(r>1)}(o)}(t,i,o,g);for(var p,f,x=t;t.prev!==t.next;)if(p=t.prev,f=t.next,g?l(t,i,o,g):a(t))e.push(p.i/n),e.push(t.i/n),e.push(f.i/n),w(t),t=f.next,x=f.next;else if((t=f)===x){d?1===d?r(t=c(s(t),e,n),e,n,i,o,g,2):2===d&&u(t,e,n,i,o,g):r(s(t),e,n,i,o,g,1);break}}}function a(t){var e=t.prev,n=t,i=t.next;if(v(e,n,i)>=0)return!1;for(var o=t.next.next;o!==t.prev;){if(x(e.x,e.y,n.x,n.y,i.x,i.y,o.x,o.y)&&v(o.prev,o,o.next)>=0)return!1;o=o.next}return!0}function l(t,e,n,i){var o=t.prev,s=t,r=t.next;if(v(o,s,r)>=0)return!1;for(var a=o.x<s.x?o.x<r.x?o.x:r.x:s.x<r.x?s.x:r.x,l=o.y<s.y?o.y<r.y?o.y:r.y:s.y<r.y?s.y:r.y,c=o.x>s.x?o.x>r.x?o.x:r.x:s.x>r.x?s.x:r.x,u=o.y>s.y?o.y>r.y?o.y:r.y:s.y>r.y?s.y:r.y,g=h(a,l,e,n,i),d=h(c,u,e,n,i),p=t.prevZ,f=t.nextZ;p&&p.z>=g&&f&&f.z<=d;){if(p!==t.prev&&p!==t.next&&x(o.x,o.y,s.x,s.y,r.x,r.y,p.x,p.y)&&v(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,f!==t.prev&&f!==t.next&&x(o.x,o.y,s.x,s.y,r.x,r.y,f.x,f.y)&&v(f.prev,f,f.next)>=0)return!1;f=f.nextZ}for(;p&&p.z>=g;){if(p!==t.prev&&p!==t.next&&x(o.x,o.y,s.x,s.y,r.x,r.y,p.x,p.y)&&v(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==t.prev&&f!==t.next&&x(o.x,o.y,s.x,s.y,r.x,r.y,f.x,f.y)&&v(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function c(t,e,n){var i=t;do{var o=i.prev,r=i.next.next;!m(o,r)&&_(o,i,i.next,r)&&C(o,r)&&C(r,o)&&(e.push(o.i/n),e.push(i.i/n),e.push(r.i/n),w(i),w(i.next),i=t=r),i=i.next}while(i!==t);return s(i)}function u(t,e,n,i,o,a){var l=t;do{for(var c=l.next.next;c!==l.prev;){if(l.i!==c.i&&y(l,c)){var u=S(l,c);return l=s(l,l.next),u=s(u,u.next),r(l,e,n,i,o,a),void r(u,e,n,i,o,a)}c=c.next}l=l.next}while(l!==t)}function g(t,e){return t.x-e.x}function d(t,e){if(e=function(t,e){var n,i=e,o=t.x,s=t.y,r=-1/0;do{if(s<=i.y&&s>=i.next.y&&i.next.y!==i.y){var a=i.x+(s-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(a<=o&&a>r){if(r=a,a===o){if(s===i.y)return i;if(s===i.next.y)return i.next}n=i.x<i.next.x?i:i.next}}i=i.next}while(i!==e);if(!n)return null;if(o===r)return n;var l,c=n,u=n.x,g=n.y,d=1/0;i=n;do{o>=i.x&&i.x>=u&&o!==i.x&&x(s<g?o:r,s,u,g,s<g?r:o,s,i.x,i.y)&&(l=Math.abs(s-i.y)/(o-i.x),C(i,t)&&(l<d||l===d&&(i.x>n.x||i.x===n.x&&p(n,i)))&&(n=i,d=l)),i=i.next}while(i!==c);return n}(t,e)){var n=S(e,t);s(e,e.next),s(n,n.next)}}function p(t,e){return v(t.prev,t,e.prev)<0&&v(e.next,t,t.next)<0}function h(t,e,n,i,o){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*o)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*o)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function f(t){var e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function x(t,e,n,i,o,s,r,a){return(o-r)*(e-a)-(t-r)*(s-a)>=0&&(t-r)*(i-a)-(n-r)*(e-a)>=0&&(n-r)*(s-a)-(o-r)*(i-a)>=0}function y(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&_(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(C(t,e)&&C(e,t)&&function(t,e){var n=t,i=!1,o=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&o<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(v(t.prev,t,e.prev)||v(t,e.prev,e))||m(t,e)&&v(t.prev,t,t.next)>0&&v(e.prev,e,e.next)>0)}function v(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function m(t,e){return t.x===e.x&&t.y===e.y}function _(t,e,n,i){var o=b(v(t,e,n)),s=b(v(t,e,i)),r=b(v(n,i,t)),a=b(v(n,i,e));return o!==s&&r!==a||(!(0!==o||!P(t,n,e))||(!(0!==s||!P(t,i,e))||(!(0!==r||!P(n,t,i))||!(0!==a||!P(n,e,i)))))}function P(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function b(t){return t>0?1:t<0?-1:0}function C(t,e){return v(t.prev,t,t.next)<0?v(t,e,t.next)>=0&&v(t,t.prev,e)>=0:v(t,e,t.prev)<0||v(t,t.next,e)<0}function S(t,e){var n=new z(t.i,t.x,t.y),i=new z(e.i,e.x,e.y),o=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=o,o.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function L(t,e,n,i){var o=new z(t,e,n);return i?(o.next=i.next,o.prev=i,i.next.prev=o,i.next=o):(o.prev=o,o.next=o),o}function w(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function z(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function A(t,e,n,i){for(var o=0,s=e,r=n-i;s<n;s+=i)o+=(t[r]-t[s])*(t[s+1]+t[r+1]),r=s;return o}t.exports=i,t.exports.default=i,i.deviation=function(t,e,n,i){var o=e&&e.length,s=o?e[0]*n:t.length,r=Math.abs(A(t,0,s,n));if(o)for(var a=0,l=e.length;a<l;a++){var c=e[a]*n,u=a<l-1?e[a+1]*n:t.length;r-=Math.abs(A(t,c,u,n))}var g=0;for(a=0;a<i.length;a+=3){var d=i[a]*n,p=i[a+1]*n,h=i[a+2]*n;g+=Math.abs((t[d]-t[h])*(t[p+1]-t[d+1])-(t[d]-t[p])*(t[h+1]-t[d+1]))}return 0===r&&0===g?0:Math.abs((g-r)/r)},i.flatten=function(t){for(var e=t[0][0].length,n={vertices:[],holes:[],dimensions:e},i=0,o=0;o<t.length;o++){for(var s=0;s<t[o].length;s++)for(var r=0;r<e;r++)n.vertices.push(t[o][s][r]);o>0&&(i+=t[o-1].length,n.holes.push(i))}return n}},4739:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var i="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";const o={lightSources:{}};function s({color:t=[0,0,0],intensity:e=1}={}){return t.map(t=>t*e/255)}const r={name:"lights",vs:i,fs:i,getUniforms:function t(e=o){if("lightSources"in e){const{ambientLight:t,pointLights:n,directionalLights:i}=e.lightSources||{};return t||n&&n.length>0||i&&i.length>0?Object.assign({},function({ambientLight:t,pointLights:e=[],directionalLights:n=[]}){const i={};return i["lighting_uAmbientLight.color"]=t?s(t):[0,0,0],e.forEach((t,e)=>{i["lighting_uPointLight[".concat(e,"].color")]=s(t),i["lighting_uPointLight[".concat(e,"].position")]=t.position,i["lighting_uPointLight[".concat(e,"].attenuation")]=t.attenuation||[1,0,0]}),i.lighting_uPointLightCount=e.length,n.forEach((t,e)=>{i["lighting_uDirectionalLight[".concat(e,"].color")]=s(t),i["lighting_uDirectionalLight[".concat(e,"].direction")]=t.direction}),i.lighting_uDirectionalLightCount=n.length,i}({ambientLight:t,pointLights:n,directionalLights:i}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in e){const n={pointLights:[],directionalLights:[]};for(const t of e.lights||[])switch(t.type){case"ambient":n.ambientLight=t;break;case"directional":n.directionalLights.push(t);break;case"point":n.pointLights.push(t)}return t({lightSources:n})}return{}},defines:{MAX_LIGHTS:3}};var a="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";const l={};function c(t=l){if(!("material"in t))return{};const{material:e}=t;return e?function(t){const{ambient:e=.35,diffuse:n=.6,shininess:i=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:e,lighting_uDiffuse:n,lighting_uShininess:i,lighting_uSpecularColor:o.map(t=>t/255)}}(e):{lighting_uEnabled:!1}}const u={name:"gouraud-lighting",dependencies:[r],vs:a,defines:{LIGHTING_VERTEX:1},getUniforms:c}},4740:function(t,e,n){"use strict";n.d(e,"a",(function(){return u}));var i=n(4717),o=n(4802),s=n(4837),r=n(4992),a=n(4803);const l=[0,0,0,255],c={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,getPosition:{type:"accessor",value:t=>t.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:l},getLineColor:{type:"accessor",value:l},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class u extends i.a{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool billboard;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = smoothedge(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter);\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.a,s.a]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState({props:t,oldProps:e,changeFlags:n}){if(super.updateState({props:t,oldProps:e,changeFlags:n}),n.extensionsChanged){var i;const{gl:t}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{viewport:e}=this.context,{radiusUnits:n,radiusScale:i,radiusMinPixels:o,radiusMaxPixels:s,stroked:r,filled:a,billboard:l,lineWidthUnits:c,lineWidthScale:u,lineWidthMinPixels:g,lineWidthMaxPixels:d}=this.props,p="pixels"===n?e.metersPerPixel:1,h="pixels"===c?e.metersPerPixel:1;this.state.model.setUniforms(t).setUniforms({stroked:r?1:0,filled:a,billboard:l,radiusScale:i*p,radiusMinPixels:o,radiusMaxPixels:s,lineWidthScale:u*h,lineWidthMinPixels:g,lineWidthMaxPixels:d}).draw()}_getModel(t){return new r.a(t,{...this.getShaders(),id:this.props.id,geometry:new a.a({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0})}}u.layerName="ScatterplotLayer",u.defaultProps=c},4756:function(t,e,n){"use strict";t.exports=i,t.exports.default=i;function i(t,e,n,i,o,s){this.fontSize=t||24,this.buffer=void 0===e?3:e,this.cutoff=i||.25,this.fontFamily=o||"sans-serif",this.fontWeight=s||"normal",this.radius=n||8;var r=this.size=this.fontSize+2*this.buffer,a=r+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=r,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textAlign="left",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(a*a),this.gridInner=new Float64Array(a*a),this.f=new Float64Array(a),this.z=new Float64Array(a+1),this.v=new Uint16Array(a),this.useMetrics=void 0!==this.ctx.measureText("A").actualBoundingBoxLeft,this.middle=Math.round(r/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}function o(t,e,n,i,o,r){for(var a=0;a<e;a++)s(t,a,e,n,i,o,r);for(var l=0;l<n;l++)s(t,l*e,1,e,i,o,r)}function s(t,e,n,i,o,s,r){var a,l,c,u;for(s[0]=0,r[0]=-1e20,r[1]=1e20,a=0;a<i;a++)o[a]=t[e+a*n];for(a=1,l=0,c=0;a<i;a++){do{u=s[l],c=(o[a]-o[u]+a*a-u*u)/(a-u)/2}while(c<=r[l]&&--l>-1);s[++l]=a,r[l]=c,r[l+1]=1e20}for(a=0,l=0;a<i;a++){for(;r[l+1]<a;)l++;u=s[l],t[e+a*n]=o[u]+(a-u)*(a-u)}}i.prototype._draw=function(t,e){var n,i,s,r,a,l,c,u,g,d=this.ctx.measureText(t),p=d.width,h=2*this.buffer;e&&this.useMetrics?(a=Math.floor(d.actualBoundingBoxAscent),u=this.buffer+Math.ceil(d.actualBoundingBoxAscent),l=this.buffer,c=this.buffer,n=(i=Math.min(this.size,Math.ceil(d.actualBoundingBoxRight-d.actualBoundingBoxLeft)))+h,s=(r=Math.min(this.size-l,Math.ceil(d.actualBoundingBoxAscent+d.actualBoundingBoxDescent)))+h,this.ctx.textBaseline="alphabetic"):(n=i=this.size,s=r=this.size,a=19*this.fontSize/24,l=c=0,u=this.middle,this.ctx.textBaseline="middle"),i&&r&&(this.ctx.clearRect(c,l,i,r),this.ctx.fillText(t,this.buffer,u),g=this.ctx.getImageData(c,l,i,r));var f=new Uint8ClampedArray(n*s);return function(t,e,n,i,o,s,r){s.fill(1e20,0,e*n),r.fill(0,0,e*n);for(var a=(e-i)/2,l=0;l<o;l++)for(var c=0;c<i;c++){var u=(l+a)*e+c+a,g=t.data[4*(l*i+c)+3]/255;if(1===g)s[u]=0,r[u]=1e20;else if(0===g)s[u]=1e20,r[u]=0;else{var d=Math.max(0,.5-g),p=Math.max(0,g-.5);s[u]=d*d,r[u]=p*p}}}(g,n,s,i,r,this.gridOuter,this.gridInner),o(this.gridOuter,n,s,this.f,this.v,this.z),o(this.gridInner,n,s,this.f,this.v,this.z),function(t,e,n,i,o,s,r){for(var a=0;a<e*n;a++){var l=Math.sqrt(i[a])-Math.sqrt(o[a]);t[a]=Math.round(255-255*(l/s+r))}}(f,n,s,this.gridOuter,this.gridInner,this.radius,this.cutoff),{data:f,metrics:{width:i,height:r,sdfWidth:n,sdfHeight:s,top:a,left:0,advance:p}}},i.prototype.draw=function(t){return this._draw(t,!1).data},i.prototype.drawWithMetrics=function(t){return this._draw(t,!0)}},4757:function(t,e,n){"use strict";n.d(e,"a",(function(){return a}));var i=n(4692),o=n(4686),s=n(4671),r=n(4689);class a{constructor(t={}){const{attributes:e={}}=t;this.typedArrayManager=o.a,this.indexStarts=null,this.vertexStarts=null,this.vertexCount=0,this.instanceCount=0,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t),Object.seal(this)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:n={},getGeometry:i,geometryBuffer:o,positionFormat:r,dataChanged:a,normalize:l=!0}=this.opts;if(this.data=e,this.getGeometry=i,this.positionSize=o&&o.size||("XY"===r?2:3),this.buffers=n,this.normalize=l,o&&(Object(s.a)(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),l||(n.positions=o)),this.geometryBuffer=n.positions,Array.isArray(a))for(const t of a)this._rebuildGeometry(t);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}normalizeGeometry(t){return t}updateGeometryAttributes(t,e,n){throw new Error("Not implemented")}getGeometrySize(t){throw new Error("Not implemented")}getGeometryFromBuffer(t){const e=t.value||t;return Object(s.a)(ArrayBuffer.isView(e)),Object(i.b)(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices})}_allocate(t,e){const{attributes:n,buffers:i,_attributeDefs:o,typedArrayManager:s}=this;for(const r in o)if(r in i)s.release(n[r]),n[r]=null;else{const i=o[r];i.copy=e,n[r]=s.allocate(n[r],t,i)}}_forEachGeometry(t,e,n){const{data:o,getGeometry:s}=this,{iterable:r,objectInfo:a}=Object(i.a)(o,e,n);for(const e of r){a.index++,t(s(e,a),a.index)}}_rebuildGeometry(t){if(!this.data||!this.getGeometry)return;let{indexStarts:e,vertexStarts:n,instanceCount:i}=this;const{data:o,geometryBuffer:s}=this,{startRow:a=0,endRow:l=1/0}=t||{},c={};if(t||(e=[0],n=[0]),this.normalize||!s)this._forEachGeometry((t,e)=>{t=this.normalizeGeometry(t),c[e]=t,n[e+1]=n[e]+this.getGeometrySize(t)},a,l),i=n[n.length-1];else if(s.buffer instanceof r.a){const t=s.stride||4*this.positionSize;n=o.startIndices,i=n[o.length]||s.buffer.byteLength/t}else{const t=s.value||s,e=s.stride/t.BYTES_PER_ELEMENT||this.positionSize;n=o.startIndices,i=n[o.length]||t.length/e}this._allocate(i,Boolean(t)),this.indexStarts=e,this.vertexStarts=n,this.instanceCount=i;const u={};this._forEachGeometry((t,o)=>{t=c[o]||t,u.vertexStart=n[o],u.indexStart=e[o];const s=o<n.length-1?n[o+1]:i;u.geometrySize=s-n[o],u.geometryIndex=o,this.updateGeometryAttributes(t,u)},a,l),this.vertexCount=e[e.length-1]}}},4829:function(t,e,n){"use strict";n.r(e),n.d(e,"getLayer",(function(){return At}));var i=n(0),o=n.n(i),s=n(2),r=n.n(s),a=n(4723),l=n(4653),c=n(4712);var u=n(4717),g=n(4802),d=n(4837),p=n(4992),h=n(4803),f=n(4995),x=n(4997),y=n(4772),v=n(5053),m=n(5048),_=n(4692);const P=()=>{},b={10241:9987,10240:9729,10242:33071,10243:33071};function C(t,e,n,i){return n===e.width&&i===e.height?e:(t.canvas.height=i,t.canvas.width=n,t.clearRect(0,0,t.canvas.width,t.canvas.height),t.drawImage(e,0,0,e.width,e.height,0,0,n,i),t.canvas)}function S(t){return t&&(t.id||t.url)}function L(t,e,n){for(let i=0;i<e.length;i++){const{icon:o,xOffset:s}=e[i];t[S(o)]={...o,x:s,y:n}}}class w{constructor(t,{onUpdate:e=P,onError:n=P}){this.gl=t,this.onUpdate=e,this.onError=n,this._loadOptions=null,this._getIcon=null,this._texture=null,this._externalTexture=null,this._mapping={},this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=4,this._canvasWidth=1024,this._canvasHeight=0,this._canvas=null}finalize(){var t;null===(t=this._texture)||void 0===t||t.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(t){const e=this._autoPacking?S(t):t;return this._mapping[e]||{}}setProps({loadOptions:t,autoPacking:e,iconAtlas:n,iconMapping:i,data:o,getIcon:s}){t&&(this._loadOptions=t),void 0!==e&&(this._autoPacking=e),s&&(this._getIcon=s),i&&(this._mapping=i),n&&this._updateIconAtlas(n),this._autoPacking&&(o||s)&&"undefined"!=typeof document&&(this._canvas=this._canvas||document.createElement("canvas"),this._updateAutoPacking(o))}get isLoaded(){return 0===this._pendingCount}_updateIconAtlas(t){var e;null===(e=this._texture)||void 0===e||e.delete(),this._texture=null,this._externalTexture=t,this.onUpdate()}_updateAutoPacking(t){const e=Object.values(function(t,e,n){if(!t||!e)return null;n=n||{};const i={},{iterable:o,objectInfo:s}=Object(_.a)(t);for(const t of o){s.index++;const o=e(t,s),r=S(o);if(!o)throw new Error("Icon is missing.");if(!o.url)throw new Error("Icon url is missing.");i[r]||n[r]&&o.url===n[r].url||(i[r]={...o,source:t,sourceIndex:s.index})}return i}(t,this._getIcon,this._mapping)||{});if(e.length>0){const{mapping:t,xOffset:n,yOffset:i,rowHeight:o,canvasHeight:s}=function({icons:t,buffer:e,mapping:n={},xOffset:i=0,yOffset:o=0,rowHeight:s=0,canvasWidth:r}){let a=[];for(let l=0;l<t.length;l++){const c=t[l];if(!n[S(c)]){const{height:t,width:l}=c;i+l+e>r&&(L(n,a,o),i=0,o=s+o+e,s=0,a=[]),a.push({icon:c,xOffset:i}),i=i+l+e,s=Math.max(s,t)}}return a.length>0&&L(n,a,o),{mapping:n,rowHeight:s,xOffset:i,yOffset:o,canvasWidth:r,canvasHeight:(l=s+o+e,Math.pow(2,Math.ceil(Math.log2(l))))};var l}({icons:e,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=t,this._xOffset=n,this._yOffset=i,this._canvasHeight=s,this._texture||(this._texture=new y.a(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:b})),this._texture.height!==this._canvasHeight&&(this._texture=function(t,e,n,i){const o=e.width,s=e.height,r=Object(f.a)(e,{width:n,height:i});return Object(x.b)(e,r,{targetY:0,width:o,height:s}),e.delete(),r}(this.gl,this._texture,this._canvasWidth,this._canvasHeight)),this.onUpdate(),this._loadIcons(e)}}_loadIcons(t){const e=this._canvas.getContext("2d");for(const n of t)this._pendingCount++,Object(m.a)(n.url,v.a,this._loadOptions).then(t=>{const i=S(n),{x:o,y:s,width:r,height:a}=this._mapping[i],l=C(e,t,r,a);this._texture.setSubImageData({data:l,x:o,y:s,width:r,height:a}),this._texture.generateMipmap(),this.onUpdate()}).catch(t=>{this.onError({url:n.url,source:n.source,sourceIndex:n.sourceIndex,loadOptions:this._loadOptions,error:t})}).finally(()=>{this._pendingCount--})}}const z=[0,0,0,255],A={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:t=>t.position},getIcon:{type:"accessor",value:t=>t.icon},getColor:{type:"accessor",value:z},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,compare:!1,optional:!0}};class I extends u.a{getShaders(){return super.getShaders({vs:"#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[g.a,d.a]})}initializeState(){this.state={iconManager:new w(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})},this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:z},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState({oldProps:t,props:e,changeFlags:n}){super.updateState({props:e,oldProps:t,changeFlags:n});const i=this.getAttributeManager(),{iconAtlas:o,iconMapping:s,data:r,getIcon:a}=e,{iconManager:l}=this.state;l.setProps({loadOptions:e.loadOptions});let c=!1;if(o||this.internalState.isAsyncPropLoading("iconAtlas")?(t.iconAtlas!==e.iconAtlas&&l.setProps({iconAtlas:o,autoPacking:!1}),t.iconMapping!==e.iconMapping&&(l.setProps({iconMapping:s}),c=!0)):l.setProps({autoPacking:!0}),(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&l.setProps({data:r,getIcon:a}),c&&(i.invalidate("instanceOffsets"),i.invalidate("instanceIconFrames"),i.invalidate("instanceColorModes")),n.extensionsChanged){var u;const{gl:t}=this.context;null===(u=this.state.model)||void 0===u||u.delete(),this.state.model=this._getModel(t),i.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(){super.finalizeState(),this.state.iconManager.finalize()}draw({uniforms:t}){const{sizeScale:e,sizeMinPixels:n,sizeMaxPixels:i,sizeUnits:o,billboard:s,alphaCutoff:r}=this.props,{iconManager:a}=this.state,{viewport:l}=this.context,c=a.getTexture();c&&this.state.model.setUniforms(t).setUniforms({iconsTexture:c,iconsTextureDim:[c.width,c.height],sizeScale:e*("pixels"===o?l.metersPerPixel:1),sizeMinPixels:n,sizeMaxPixels:i,billboard:s,alphaCutoff:r}).draw()}_getModel(t){return new p.a(t,{...this.getShaders(),id:this.props.id,geometry:new h.a({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(t){const{onIconError:e}=this.getCurrentLayer().props;e?e(t):l.a.error(t.error)()}getInstanceOffset(t){const e=this.state.iconManager.getIconMapping(t);return[e.width/2-e.anchorX||0,e.height/2-e.anchorY||0]}getInstanceColorMode(t){return this.state.iconManager.getIconMapping(t).mask?1:0}getInstanceIconFrame(t){const e=this.state.iconManager.getIconMapping(t);return[e.x||0,e.y||0,e.width||0,e.height||0]}}I.layerName="IconLayer",I.defaultProps=A;var O=n(4740);const M=[];class E extends I{getShaders(){return{...super.getShaders(),fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float buffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"}}initializeState(){super.initializeState(),this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(t,{index:e,target:n})=>this.encodePickingColor(e,n)}})}updateState(t){super.updateState(t);const{props:e,oldProps:n}=t;let{outlineColor:i}=e;i!==n.outlineColor&&(i=i.map(t=>t/255),i[3]=Number.isFinite(i[3])?i[3]:1,this.setState({outlineColor:i})),!e.sdf&&e.outlineWidth&&l.a.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(t){const{sdf:e,smoothing:n,outlineWidth:i}=this.props,{outlineColor:o}=this.state;t.uniforms={...t.uniforms,buffer:.75,outlineBuffer:i?Math.max(n,.75*(1-i)):-1,gamma:n,sdf:Boolean(e),outlineColor:o},super.draw(t)}getInstanceOffset(t){return t?Array.from(t).map(t=>super.getInstanceOffset(t)):M}getInstanceColorMode(t){return 1}getInstanceIconFrame(t){return t?Array.from(t).map(t=>super.getInstanceIconFrame(t)):M}}E.layerName="MultiIconLayer",E.defaultProps={getIconOffsets:{type:"accessor",value:t=>t.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}};var T=n(4756),F=n.n(T);const R=[];function k(t,e,n,i){let o=0;for(let s=e;s<n;s++){const e=t[s];let n=null;const r=i&&i[e];r&&(n=r.width),o+=n}return o}function W(t,e,n,i,o,s){let r=e,a=0;for(let l=e;l<n;l++){const e=k(t,l,l+1,o);a+e>i&&(r<l&&s.push(l),r=l,a=0),a+=e}return a}function G(t,e,n,i,o=0,s){void 0===s&&(s=t.length);const r=[];return"break-all"===e?W(t,o,s,n,i,r):function(t,e,n,i,o,s){let r=e,a=e,l=e,c=0;for(let u=e;u<n;u++)if(" "===t[u]?l=u+1:" "!==t[u+1]&&u+1!==n||(l=u+1),l>a){let e=k(t,a,l,o);c+e>i&&(r<a&&(s.push(a),r=a,c=0),e>i&&(e=W(t,a,l,i,o,s),r=s[s.length-1])),a=l,c+=e}}(t,o,s,n,i,r),r}function B(t,e,n,i,o,s){let r=0,a=0;for(let s=e;s<n;s++){const e=t[s],n=i[e];n?(a||(a=n.height),o[s]=r+n.width/2,r+=n.width):(l.a.warn("Missing character: ".concat(e," (").concat(e.codePointAt(0),")"))(),o[s]=r,r+=32)}s[0]=r,s[1]=a}function j(t,e,n,i,o){const s=(t=Array.from(t)).length,r=new Array(s),a=new Array(s),l=new Array(s),c=("break-word"===n||"break-all"===n)&&isFinite(i)&&i>0,u=[0,0],g=[];let d=0,p=0,h=0;for(let f=0;f<=s;f++){const x=t[f];if("\n"!==x&&f!==s||(h=f),h>p){const s=c?G(t,n,i,o,p,h):R;for(let n=0;n<=s.length;n++){const i=0===n?p:s[n-1],c=n<s.length?s[n]:h;B(t,i,c,o,r,g);for(let t=i;t<c;t++)a[t]=d+g[1]/2,l[t]=g[0];d+=g[1]*e,u[0]=Math.max(u[0],g[0])}p=h}"\n"===x&&(r[p]=0,a[p]=0,l[p]=0,p++)}return u[1]=d,{x:r,y:a,rowWidth:l,size:u}}const D=function(){const t=[];for(let e=32;e<128;e++)t.push(String.fromCharCode(e));return t}(),N=new class{constructor(t=5){this.limit=t,this.clear()}clear(){this._cache={},this._order=[]}get(t){const e=this._cache[t];return e&&(this._deleteOrder(t),this._appendOrder(t)),e}set(t,e){this._cache[t]?(this.delete(t),this._cache[t]=e,this._appendOrder(t)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[t]=e,this._appendOrder(t))}delete(t){this._cache[t]&&(this._deleteCache(t),this._deleteOrder(t))}_deleteCache(t){delete this._cache[t]}_deleteOrder(t){const e=this._order.findIndex(e=>e===t);e>=0&&this._order.splice(e,1)}_appendOrder(t){this._order.push(t)}}(3),U=["fontFamily","fontWeight","characterSet","fontSize","sdf","buffer","cutoff","radius"];function H(t,e){for(let n=0;n<t.length;n++)e.data[4*n+3]=t[n]}function V(t,e,n,i){t.font="".concat(i," ").concat(n,"px ").concat(e),t.fillStyle="#000",t.textBaseline="baseline",t.textAlign="left"}class Z{constructor(){this.props={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:D,fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12},this._key=null,this._atlas=null}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){return 1.2}setProps(t={}){U.forEach(e=>{e in t&&(this.props[e]=t[e])});const e=this._key;this._key=this._getKey();const n=function(t,e){const n=N.get(t);if(!n)return e;const i=[],o=n.mapping;let s=Object.keys(o);s=new Set(s);let r=e;return r instanceof Array&&(r=new Set(r)),r.forEach(t=>{s.has(t)||i.push(t)}),i}(this._key,this.props.characterSet),i=N.get(this._key);if(i&&0===n.length)return void(this._key!==e&&(this._atlas=i));const o=this._generateFontAtlas(this._key,n,i);this._atlas=o,N.set(this._key,o)}_generateFontAtlas(t,e,n){const{fontFamily:i,fontWeight:o,fontSize:s,buffer:r,sdf:a,radius:l,cutoff:c}=this.props;let u=n&&n.data;u||(u=document.createElement("canvas"),u.width=1024);const g=u.getContext("2d");V(g,i,s,o);const{mapping:d,canvasHeight:p,xOffset:h,yOffset:f}=function({characterSet:t,getFontWidth:e,fontHeight:n,buffer:i,maxCanvasWidth:o,mapping:s={},xOffset:r=0,yOffset:a=0}){let l=0,c=r,u=0;for(const r of t)if(!s[r]){const t=e(r,u++);c+t+2*i>o&&(c=0,l++),s[r]={x:c+i,y:a+l*(n+2*i)+i,width:t,height:n},c+=t+2*i}const g=n+2*i;return{mapping:s,xOffset:c,yOffset:a+l*g,canvasHeight:(d=a+(l+1)*g,Math.pow(2,Math.ceil(Math.log2(d))))};var d}({getFontWidth:t=>g.measureText(t).width,fontHeight:1.2*s,buffer:r,characterSet:e,maxCanvasWidth:1024,...n&&{mapping:n.mapping,xOffset:n.xOffset,yOffset:n.yOffset}});if(u.height!==p){const t=g.getImageData(0,0,u.width,u.height);u.height=p,g.putImageData(t,0,0)}if(V(g,i,s,o),a){const t=new F.a(s,r,l,c,i,o),n=g.getImageData(0,0,t.size,t.size);for(const i of e)H(t.draw(i),n),g.putImageData(n,d[i].x-r,d[i].y+r)}else for(const t of e)g.fillText(t,d[t].x,d[t].y+.9*s);return{xOffset:h,yOffset:f,mapping:d,data:u,width:u.width,height:u.height}}_getKey(){const{fontFamily:t,fontWeight:e,fontSize:n,buffer:i,sdf:o,radius:s,cutoff:r}=this.props;return o?"".concat(t," ").concat(e," ").concat(n," ").concat(i," ").concat(s," ").concat(r):"".concat(t," ").concat(e," ").concat(n," ").concat(i)}}const K={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:t=>t.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class J extends u.a{getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[g.a,d.a]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState({props:t,oldProps:e,changeFlags:n}){if(super.updateState({props:t,oldProps:e,changeFlags:n}),n.extensionsChanged){var i;const{gl:t}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{viewport:e}=this.context,{billboard:n,sizeScale:i,sizeUnits:o,sizeMinPixels:s,sizeMaxPixels:r,getLineWidth:a}=this.props;let{padding:l}=this.props;const c="pixels"===o?e.metersPerPixel:1;l.length<4&&(l=[l[0],l[1],l[0],l[1]]),this.state.model.setUniforms(t).setUniforms({billboard:n,stroked:Boolean(a),padding:l,sizeScale:i*c,sizeMinPixels:s,sizeMaxPixels:r}).draw()}_getModel(t){return new p.a(t,{...this.getShaders(),id:this.props.id,geometry:new h.a({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}J.layerName="TextBackgroundLayer",J.defaultProps=K;const X={fontSize:64,buffer:4,sdf:!1,radius:12,cutoff:.25,smoothing:.1},Y={start:1,middle:0,end:-1},q={top:1,center:0,bottom:-1},Q=[0,0,0,255],$=["fontSize","buffer","sdf","radius","cutoff"],tt={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:Q},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:D},fontFamily:"Monaco, monospace",fontWeight:"normal",lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:Q},fontSettings:{},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:t=>t.text},getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:Q},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class et extends a.a{initializeState(){this.state={styleVersion:0,fontAtlasManager:new Z}}updateState({props:t,oldProps:e,changeFlags:n}){const i=n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText),o=this.state.characterSet;i&&this._updateText();const s=o!==this.state.characterSet||this._fontChanged(e,t);s&&this._updateFontAtlas(e,t),(s||t.lineHeight!==e.lineHeight||t.wordBreak!==e.wordBreak||t.maxWidth!==e.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:t}){return t.object=t.index>=0?this.props.data[t.index]:null,t}_updateFontAtlas(t,e){const{fontSettings:n,fontFamily:i,fontWeight:o}=e,{fontAtlasManager:s,characterSet:r}=this.state;s.setProps({...X,...n,characterSet:r,fontFamily:i,fontWeight:o})}_fontChanged(t,e){if(t.fontFamily!==e.fontFamily||t.fontWeight!==e.fontWeight)return!0;if(t.fontSettings===e.fontSettings)return!1;const n=t.fontSettings||{},i=e.fontSettings||{};return $.some(t=>n[t]!==i[t])}_updateText(){const{data:t,characterSet:e}=this.props,n=t.attributes&&t.attributes.getText;let i,{getText:o}=this.props,{startIndices:s}=t;const r="auto"===e&&new Set;if(n&&s){const{texts:e,characterCount:a}=function({value:t,length:e,stride:n,offset:i,startIndices:o,characterSet:s}){const r=t.BYTES_PER_ELEMENT,a=n?n/r:1,l=i?i/r:0,c=o[e]||Math.ceil((t.length-l)/a),u=s&&new Set,g=new Array(e);let d=t;if(a>1||l>0){d=new t.constructor(c);for(let e=0;e<c;e++)d[e]=t[e*a+l]}for(let t=0;t<e;t++){const e=o[t],n=o[t+1]||c,i=d.subarray(e,n);g[t]=String.fromCodePoint.apply(null,i),u&&i.forEach(u.add,u)}if(u)for(const t of u)s.add(String.fromCodePoint(t));return{texts:g,characterCount:c}}({...ArrayBuffer.isView(n)?{value:n}:n,length:t.length,startIndices:s,characterSet:r});i=a,o=(t,{index:n})=>e[n]}else{const{iterable:e,objectInfo:n}=Object(_.a)(t);s=[0],i=0;for(const t of e){n.index++;const e=Array.from(o(t,n)||"");r&&e.forEach(r.add,r),i+=e.length,s.push(i)}}this.setState({getText:o,startIndices:s,numInstances:i,characterSet:r||e})}getBoundingRect(t,e){const n=this.state.fontAtlasManager.mapping,{getText:i}=this.state,{wordBreak:o,maxWidth:s,lineHeight:r,getTextAnchor:a,getAlignmentBaseline:l}=this.props,c=i(t,e)||"",{size:[u,g]}=j(c,r,o,s,n);return[(Y["function"==typeof a?a(t,e):a]-1)*u/2,(q["function"==typeof l?l(t,e):l]-1)*g/2,u,g]}getIconOffsets(t,e){const n=this.state.fontAtlasManager.mapping,{getText:i}=this.state,{wordBreak:o,maxWidth:s,lineHeight:r,getTextAnchor:a,getAlignmentBaseline:l}=this.props,c=i(t,e)||"",{x:u,y:g,rowWidth:d,size:[p,h]}=j(c,r,o,s,n),f=Y["function"==typeof a?a(t,e):a],x=q["function"==typeof l?l(t,e):l],y=u.length,v=new Array(2*y);let m=0;for(let t=0;t<y;t++){const e=(1-f)*(p-d[t])/2;v[m++]=(f-1)*p/2+e+u[t],v[m++]=(x-1)*h/2+g[t]}return v}renderLayers(){const{startIndices:t,numInstances:e,getText:n,fontAtlasManager:{scale:i,texture:o,mapping:s},styleVersion:r}=this.state,{data:a,_dataDiff:l,getPosition:c,getColor:u,getSize:g,getAngle:d,getPixelOffset:p,getBackgroundColor:h,getBorderColor:f,getBorderWidth:x,backgroundPadding:y,background:v,billboard:m,fontSettings:_,outlineWidth:P,outlineColor:b,sizeScale:C,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z,updateTriggers:A}=this.props,I=this.getSubLayerClass("characters",E),O=this.getSubLayerClass("background",J);return[v&&new O({getFillColor:h,getLineColor:f,getLineWidth:x,padding:y,getPosition:c,getSize:g,getAngle:d,getPixelOffset:p,billboard:m,sizeScale:C/this.state.fontAtlasManager.props.fontSize,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getSize:z.getSize,getFillColor:z.getBackgroundColor,getLineColor:z.getBorderColor,getLineWidth:z.getBorderWidth,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:A.getPosition,getAngle:A.getAngle,getSize:A.getSize,getFillColor:A.getBackgroundColor,getLineColor:A.getBorderColor,getLineWidth:A.getBorderWidth,getPixelOffset:A.getPixelOffset,getBoundingRect:{getText:A.getText,getTextAnchor:A.getTextAnchor,getAlignmentBaseline:A.getAlignmentBaseline,styleVersion:r}}}),{data:a.attributes?{length:a.length,attributes:a.attributes.background||{}}:a,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect.bind(this)}),new I({sdf:_.sdf,smoothing:Number.isFinite(_.smoothing)?_.smoothing:X.smoothing,outlineWidth:P,outlineColor:b,iconAtlas:o,iconMapping:s,getPosition:c,getColor:u,getSize:g,getAngle:d,getPixelOffset:p,billboard:m,sizeScale:C*i,sizeUnits:S,sizeMinPixels:L*i,sizeMaxPixels:w*i,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getColor:z.getColor,getSize:z.getSize,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{getIcon:A.getText,getPosition:A.getPosition,getAngle:A.getAngle,getColor:A.getColor,getSize:A.getSize,getPixelOffset:A.getPixelOffset,getIconOffsets:{getText:A.getText,getTextAnchor:A.getTextAnchor,getAlignmentBaseline:A.getAlignmentBaseline,styleVersion:r}}}),{data:a,_dataDiff:l,startIndices:t,numInstances:e,getIconOffsets:this.getIconOffsets.bind(this),getIcon:n})]}}et.layerName="TextLayer",et.defaultProps=tt;var nt=n(4698),it=n(4718);const ot={circle:{type:O.a,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:I,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:et,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},st={type:nt.a,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",getLineColor:"getColor",getLineWidth:"getWidth"}},rt={type:it.a,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function at({type:t,props:e}){const n={};for(const i in e)n[i]=t.defaultProps[e[i]];return n}function lt(t,e){const{transitions:n,updateTriggers:i}=t.props,o={updateTriggers:{},transitions:n&&{getPosition:n.geometry}};for(const s in e){const r=e[s];let a=t.props[s];s.startsWith("get")&&(a=t.getSubLayerAccessor(a),o.updateTriggers[r]=i[s],n&&(o.transitions[r]=n[s])),o[r]=a}return o}function ct(t,e,n={}){const i={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:o=0,endRow:s=t.length}=n;for(let n=o;n<s;n++){const o=t[n];l.a.assert(o&&o.geometry,"GeoJSON does not have geometry");const{geometry:s}=o;if("GeometryCollection"===s.type){l.a.assert(Array.isArray(s.geometries),"GeoJSON does not have geometries array");const{geometries:t}=s;for(let s=0;s<t.length;s++){ut(t[s],i,e,o,n)}}else ut(s,i,e,o,n)}return i}function ut(t,e,n,i,o){const{type:s,coordinates:r}=t,{pointFeatures:a,lineFeatures:c,polygonFeatures:u,polygonOutlineFeatures:g}=e;if(function(t,e){let n=gt[t];l.a.assert(n,"Unknown GeoJSON type ".concat(t));for(;e&&--n>0;)e=e[0];return e&&Number.isFinite(e[0])}(s,r))switch(s){case"Point":a.push(n({geometry:t},i,o));break;case"MultiPoint":r.forEach(t=>{a.push(n({geometry:{type:"Point",coordinates:t}},i,o))});break;case"LineString":c.push(n({geometry:t},i,o));break;case"MultiLineString":r.forEach(t=>{c.push(n({geometry:{type:"LineString",coordinates:t}},i,o))});break;case"Polygon":u.push(n({geometry:t},i,o)),r.forEach(t=>{g.push(n({geometry:{type:"LineString",coordinates:t}},i,o))});break;case"MultiPolygon":r.forEach(t=>{u.push(n({geometry:{type:"Polygon",coordinates:t}},i,o)),t.forEach(t=>{g.push(n({geometry:{type:"LineString",coordinates:t}},i,o))})})}else l.a.warn("".concat(s," coordinates are malformed"))()}const gt={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function dt(t){return t.geometry.coordinates}function pt(t,e){const n={points:{},lines:{},polygons:{},polygonsOutline:{}},{points:i,lines:o,polygons:s}=t,r=function(t,e){const n={points:null,lines:null,polygons:null};for(const i in n){const o=t[i].globalFeatureIds.value;n[i]=new Uint8ClampedArray(3*o.length);const s=[];for(let t=0;t<o.length;t++)e(o[t],s),n[i][3*t+0]=s[0],n[i][3*t+1]=s[1],n[i][3*t+2]=s[2]}return n}(t,e);return n.points.data={length:i.positions.value.length/i.positions.size,attributes:{getPosition:i.positions,instancePickingColors:{size:3,value:r.points}},properties:i.properties,numericProps:i.numericProps,featureIds:i.featureIds},n.lines.data={length:o.pathIndices.value.length-1,startIndices:o.pathIndices.value,attributes:{getPath:o.positions,instancePickingColors:{size:3,value:r.lines}},properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},n.lines._pathType="open",n.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{getPolygon:s.positions,pickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},n.polygons._normalize=!1,s.triangles&&(n.polygons.data.attributes.indices=s.triangles.value),n.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{getPath:s.positions,instancePickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},n.polygonsOutline._pathType="open",n}const ht={...at(ot.circle),...at(ot.icon),...at(ot.text),...at(st),...at(rt),stroked:!0,filled:!0,extruded:!1,wireframe:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:t=>t.properties.icon},getText:{type:"accessor",value:t=>t.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}};class ft extends a.a{initializeState(){this.state={layerProps:{},features:{}},this.props.getLineDashArray&&l.a.removed("getLineDashArray","PathStyleExtension")()}updateState({props:t,changeFlags:e}){if(!e.dataChanged)return;const{data:n}=this.props,i=n&&"points"in n&&"polygons"in n&&"lines"in n;this.setState({binary:i}),i?this._updateStateBinary({props:t,changeFlags:e}):this._updateStateJSON({props:t,changeFlags:e})}_updateStateBinary({props:t,changeFlags:e}){const n=pt(t.data,this.encodePickingColor);this.setState({layerProps:n})}_updateStateJSON({props:t,changeFlags:e}){const n=function(t){if(Array.isArray(t))return t;switch(l.a.assert(t.type,"GeoJSON does not have type"),t.type){case"Feature":return[t];case"FeatureCollection":return l.a.assert(Array.isArray(t.features),"GeoJSON does not have features array"),t.features;default:return[{geometry:t}]}}(t.data),i=this.getSubLayerRow.bind(this);let o={};const s={};if(Array.isArray(e.dataChanged)){const t=this.state.features;for(const e in t)o[e]=t[e].slice(),s[e]=[];for(const r of e.dataChanged){const e=ct(n,i,r);for(const n in t)s[n].push(Object(c.a)({data:o[n],getIndex:t=>t.__source.index,dataRange:r,replace:e[n]}))}}else o=ct(n,i);const r=function(t,e){const n={points:{},lines:{},polygons:{},polygonsOutline:{}},{pointFeatures:i,lineFeatures:o,polygonFeatures:s,polygonOutlineFeatures:r}=t;return n.points.data=i,n.points._dataDiff=e.pointFeatures&&(()=>e.pointFeatures),n.points.getPosition=dt,n.lines.data=o,n.lines._dataDiff=e.lineFeatures&&(()=>e.lineFeatures),n.lines.getPath=dt,n.polygons.data=s,n.polygons._dataDiff=e.polygonFeatures&&(()=>e.polygonFeatures),n.polygons.getPolygon=dt,n.polygonsOutline.data=r,n.polygonsOutline._dataDiff=e.polygonOutlineFeatures&&(()=>e.polygonOutlineFeatures),n.polygonsOutline.getPath=dt,n}(o,s);this.setState({features:o,featuresDiff:s,layerProps:r})}_updateAutoHighlight(t){const e="".concat(this.id,"-points-"),n=t.sourceLayer.id.startsWith(e);for(const i of this.getSubLayers())i.id.startsWith(e)===n&&i.updateAutoHighlight(t)}_renderPolygonLayer(){const{extruded:t,wireframe:e}=this.props,{layerProps:n}=this.state,i="polygons-fill",o=this.shouldRenderSubLayer(i,n.polygons.data)&&this.getSubLayerClass(i,rt.type);if(o){const s=lt(this,rt.props),r=t&&e;return r||delete s.getLineColor,s.updateTriggers.lineColors=r,new o(s,this.getSubLayerProps({id:i,updateTriggers:s.updateTriggers}),n.polygons)}return null}_renderLineLayers(){const{extruded:t,stroked:e}=this.props,{layerProps:n}=this.state,i=!t&&e&&this.shouldRenderSubLayer("polygons-stroke",n.polygonsOutline.data)&&this.getSubLayerClass("polygons-stroke",st.type),o=this.shouldRenderSubLayer("linestrings",n.lines.data)&&this.getSubLayerClass("linestrings",st.type);if(i||o){const t=lt(this,st.props);return[i&&new i(t,this.getSubLayerProps({id:"polygons-stroke",updateTriggers:t.updateTriggers}),n.polygonsOutline),o&&new o(t,this.getSubLayerProps({id:"linestrings",updateTriggers:t.updateTriggers}),n.lines)]}return null}_renderPointLayers(){const{pointType:t}=this.props,{layerProps:e,binary:n}=this.state;let{highlightedObjectIndex:i}=this.props;!n&&Number.isFinite(i)&&(i=e.points.data.findIndex(t=>t.__source.index===i));const o=new Set(t.split("+")),s=[];for(const t of o){const n="points-".concat(t),o=ot[t],r=o&&this.shouldRenderSubLayer(n,e.points.data)&&this.getSubLayerClass(n,o.type);if(r){const t=lt(this,o.props);s.push(new r(t,this.getSubLayerProps({id:n,updateTriggers:t.updateTriggers,highlightedObjectIndex:i}),e.points))}}return s}renderLayers(){const{extruded:t}=this.props,e=this._renderPolygonLayer();return[!t&&e,this._renderLineLayers(),this._renderPointLayers(),t&&e]}getSubLayerAccessor(t){const{binary:e}=this.state;return e&&"function"==typeof t?(e,n)=>{const{data:i,index:o}=n,s=function(t,e){if(!t)return null;const n="startIndices"in t?t.startIndices[e]:e,i=t.featureIds.value[n];return-1!==n?function(t,e,n){const i={properties:{...t.properties[e]}};for(const e in t.numericProps)i.properties[e]=t.numericProps[e].value[n];return i}(t,i,n):null}(i,o);return t(s,n)}:super.getSubLayerAccessor(t)}}ft.layerName="GeoJsonLayer",ft.defaultProps=ht;var xt=n(4647),yt=n(4665),vt=n(4643),mt=n(4650),_t=n(4651);function Pt(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function bt(){return(bt=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}const Ct={fillColor:"fillColor",color:"fillColor",fill:"fillColor","fill-color":"fillColor",strokeColor:"strokeColor","stroke-color":"strokeColor","stroke-width":"strokeWidth"},St=(t,e)=>{const n={};return Object.keys(t).forEach(e=>{e in Ct?n[Ct[e]]=t[e]:n[e]=t[e]}),"string"==typeof t.fillColor&&(n.fillColor=Object(yt.hexToRGB)(t.fillColor)),"string"==typeof t.strokeColor&&(n.strokeColor=Object(yt.hexToRGB)(t.strokeColor)),bt({},n,{},e)};let Lt;const wt=(t,e,n)=>{if(t&&t.features&&t.features.forEach(i=>{wt(i,e,t.extraProps||n)}),t&&t.geometry){const i=bt({},t,{properties:St(t.properties,e)});i.extraProps||(i.extraProps=n),Lt.push(i)}};function zt(t){return t.object.extraProps&&o.a.createElement("div",{className:"deckgl-tooltip"},Object.keys(t.object.extraProps).map((e,n)=>o.a.createElement(_t.a,{key:"prop-"+n,label:e+": ",value:""+t.object.extraProps[e]})))}function At(t,e,n,i){const o=t,s=o.fill_color_picker,r=o.stroke_color_picker,a=[s.r,s.g,s.b,255*s.a],l=[r.r,r.g,r.b,255*r.a],c={};let u;return a[3]>0&&(c.fillColor=a),l[3]>0&&(c.strokeColor=l),Lt=[],wt(e.data,c),o.js_data_mutator&&(u=Object(vt.a)(o.js_data_mutator),Lt=u(Lt)),new ft(bt({id:"geojson-layer-"+o.slice_id,filled:o.filled,data:Lt,stroked:o.stroked,extruded:o.extruded,pointRadiusScale:o.point_radius_scale},Object(mt.a)(o,i,zt)))}const It={formData:r.a.object.isRequired,payload:r.a.object.isRequired,setControlValue:r.a.func.isRequired,viewport:r.a.object.isRequired,onAddFilter:r.a.func},Ot={onAddFilter(){}};class Mt extends o.a.Component{constructor(){super(...arguments),Pt(this,"containerRef",o.a.createRef()),Pt(this,"setTooltip",t=>{const{current:e}=this.containerRef;e&&e.setTooltip(t)})}render(){const{formData:t,payload:e,setControlValue:n,onAddFilter:i,viewport:s}=this.props,r=At(t,e,0,this.setTooltip);return o.a.createElement(xt.a,{ref:this.containerRef,mapboxApiAccessToken:e.data.mapboxApiKey,viewport:s,layers:[r],mapStyle:t.mapbox_style,setControlValue:n})}}Mt.propTypes=It,Mt.defaultProps=Ot;e.default=Mt}}]);